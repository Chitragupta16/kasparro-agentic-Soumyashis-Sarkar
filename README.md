# Kasparro Agentic Content System

## Overview
A modular, multi-agent automation system designed to generate structured marketing content (FAQ, Product Pages, Comparisons) from raw product data. This system utilizes a dedicated orchestration pipeline, deterministic logic blocks for compliance, and LLMs for creative ideation.

## Architecture
The system follows a linear Directed Acyclic Graph (DAG) flow:
1.  **Analyst Agent (Ingestion):** Parses raw text into a strict Pydantic model (`ProductData`).
2.  **Strategist Agent (Ideation):** Generates user-centric questions based on the structured model.
3.  **Publisher Agent (Assembly):** Combines data, questions, and logic rules to output production-ready JSON files.

## Setup & Execution

### Prerequisites
* Python 3.10+
* Google Gemini API Key

### Installation
1.  Clone the repository:
    ```bash
    git clone <repo-url>
    ```
2.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```
3.  Configure Environment:
    Create a `.env` file in the root:
    ```env
    GEMINI_API_KEY=your_key_here
    ```

### Running the Pipeline
Execute the module from the root directory:
```bash
python -m src.main

---

### 2. The Design Doc (`docs/projectdocumentation.md`)
**Action:** This is the most critical document for your evaluation[cite: 98]. Overwrite `docs/projectdocumentation.md` with the content below.

```markdown
# Project Documentation

## 1. Problem Statement
The objective was to design a modular agentic system capable of ingesting raw product data and autonomously generating structured content pages (FAQ, Product Description, Comparison). The system needed to adhere to strict constraints: no external research, clear agent boundaries, and machine-readable JSON output.

## 2. Solution Overview
The solution is implemented as a **Sequential Orchestration Pipeline**. It rejects the "monolithic script" approach in favor of specialized agents with distinct responsibilities:

* **Analyst Agent:** Responsible solely for **Extraction & Validation**. It ensures downstream agents never handle unstructured text.
* **Strategist Agent:** Responsible for **Creative Expansion**. It enriches the data by generating user questions.
* **Publisher Agent:** Responsible for **Deterministic Assembly**. It uses a custom Template Engine and Logic Blocks to ensure formatting consistency (e.g., price comparisons) without relying on LLM hallucination for math or logic.

## 3. Scopes & Assumptions
* **Model:** Google Gemini 1.5 Flash was chosen for its speed and efficient JSON handling.
* **Data Constancy:** The system assumes the input format remains relatively stable (Key/Value pairs).
* **Logic Isolation:** Mathematical operations (price difference) and critical warnings (safety disclaimers) are hardcoded in Python Logic Blocks, not generated by the LLM, to guarantee accuracy.
* **Competitor Data:** As per requirements, "Product B" data is structurally mocked within the Orchestrator.

## 4. System Design

### Architecture Diagram (Flow)

```mermaid
graph TD
    Raw[Raw Text Input] -->|Ingest| Analyst[Analyst Agent]
    Analyst -->|Structured Object| Model[ProductData Model]
    
    Model -->|Context| Strategist[Strategist Agent]
    Strategist -->|JSON List| Qs[Generated Questions]
    
    Model -->|Input| Publisher[Publisher Agent]
    Qs -->|Input| Publisher
    Comp[Competitor Data] -->|Input| Publisher
    
    subgraph Logic Layer
    Publisher -->|Calls| Blocks[Logic Blocks]
    Publisher -->|Uses| Templates[Template Engine]
    end
    
    Publisher -->|Write| File1[faq.json]
    Publisher -->|Write| File2[product_page.json]
    Publisher -->|Write| File3[comparison_page.json]
Key Design Decisions
Pydantic as the Protocol: Agents communicate strictly via the ProductData object. This eliminates string parsing errors between steps and ensures type safety.

Logic Blocks vs. Agents: I separated "thinking" (Agents) from "calculating" (Logic Blocks).

Agent Role: Decide what to compare.

Block Role: Calculate how much cheaper Product A is vs B.

Benefit: This prevents LLMs from making arithmetic errors or formatting currency inconsistently.

Template Engine: A custom TemplateEngine class was built to decouple content structure from content generation. This allows the format of the output JSONs to be modified without changing Agent logic.


---

### Final Submission Checklist

1.  **Verify Output:** Open `data/output/comparison_page.json`. Ensure the price comparison logic (e.g., "GlowBoost is â‚¹249 more expensive/cheaper") is accurate.
2.  **Clean Up:** Remove any `__pycache__` folders or `.env` files if you are manually zipping (though your `.gitignore` handles this for git).
3.  **Repo Name:** Ensure your folder/repo is named `kasparro-agentic-<firstname>-<lastname>`.
4.  **Push to GitHub:**
    ```bash
    git init
    git add .
    git commit -m "Initial submission: Agentic Content System"
    git branch -M main
    git remote add origin <your-github-url>
    git push -u origin main
    ```
5.  **Submit:** Send the link via the Google Form.

You are done. Good luck.